# NumPy 基础

## numpy的基础与安装方法

## 多维数据结构ndarray的基础

### ndarray

N-dimensional array

- 只能存储具有相同数据类型的元素。
- 每个维度中的元素数量必须是固定的。
- 基于C语言实现，并经过了大量优化的矩阵运算，可以实现高性能的数据处理。

### 属性

```python
import numpy as np
a = np.array([1,2,3])
type(a)
b = np.array([[1,2,3],[4,5,6]])
a
b
b.T #转置
a.T #因为a.ndim<2 所以没有变化
a.data #显示内存中的地址
a.dtype #显示数据的类型
```

```python
a.flags #可以获取各种信息
a.flat[1] #显示将a转换为一维数组后其中的第二个元素
```

```python
c = np.array([1.-2.6j, 2.1+3j, 4.-3.2j])
#创建以复数为元素的ndarray实例
c.real #显示实数部分
c.imag #显示虚数部分
```

```python
a.size #元素的数量
a.itemsize #按字节序显示每个元素的字长 在某些环境中可能是4
a.nbytes #按字节序显示数组的长度，在某些环境中可能是12
a.size * a.itemsize = a.nbytes #这个等式成立
```

```python
a.ndim #显示维数
a.shape #显示形状
```

```python
d = np.array([[[2,3,2],[2,2,2]],[[4,3,2],[5,7,1]]]) #生成三维数组
d.shape, d.ndim #显示形状和维数
a.strides #在各个维度方向上(axis=0,axis=1,...,axis=ndim-1)移动到下一个元素所需移动的字节数。在某些环境下可能为(4,)
```

```python
a.ctypes.data #使用ctypes模块的操作
a.base #a的基类数组在什么地方
e = a[:2]
e.base
e.base is a #True
a.base is e.base #False
```

### 内存布局

使用ndarray类生成的实例在内存中是以一维数组的形式进行存储的。其中作为登记信息的一部分，用于描述数据的类型、数组的形状(shape)等，以一维数组的形式保存的，用于指定读取元素数据方式的数据称为元数据。

在这些元数据的后面，是以数据形式保存的数组元素的值。其中，数据的排列方式大致可以分为两类。

一类是称为行主序(row-major)的排列方式，另一类是称为列主序(column-major)的排列方式。前者是C语言中所使用的数据排列方式，后者是FORTRAN和MATLAB等语言所使用的排列方式。

```python
.flags
C_CONTIGUOUS:True
F_CONTIGUOUS:False
```

其中，C_CONTIGUOUS用于表示是否可以使用行主序进行读取；F_CONTIGUOUS表示是否可以使用列主序进行读取。numpy的参数中，有一个参数是order，基本上设置为C就表示使用行主序进行存储；设置为F就表示使用列主序进行存储。

这两种存储方式的区别在于数据是从哪个维度方向上开始存储的。行主序是从低维度开始存储（坐标轴的编号由小到大）；列主序则是从高维度开始存储（坐标轴的编号有大到小）。

在二维数组中，列方向可以使用axis=1进行指定，行方向可以使用axis=0进行指定。虽然坐标轴的编号发生了变化，但是大小顺序依然是保持不变的。这就是数组中的数据在内存中进行存储所使用的方式。

### 步长

在列的方向上展开处理，使用的是行主序存储数据，因此每个元素之间只需要很小的内存空间距离即可。但是，如果使用列主序进行存储，由于是在行的方向上进行保存，存储时是以列为单位移动的，因此所需的字节数也更多，无法实现高效的运算。

在使用字节数表示访问每个元素时，这个在内存空间中所需移动的距离的属性称为步长（strides）。

步长是ndarray的属性之一，通过这个属性值，就可以知道元素之间的距离。下面将尝试分别使用列主序和行主序保存同一个数组对象。

```python
a = np.random.randn(100, 100)
b = np.array(a, order='C') #行主序
c = np.array(a, order='F') #列主序
b.strides, c.strides #从步长上看，二者是相反的
np.allclose(b, c) #确认数组的元素是否完全相同
```

接下来，将使用切片功能指定每隔100个元素进行读取操作，并对程序的执行速度进行统计。这样操作，在内存中对数值进行读取时，为了读取相邻的元素的值，需要跳转的字节也会相应增加，因此程序的执行速度也会随之降低。

```python
x = np.ones((100000,)) #将所有的元素都初始化为1
y = np.ones((100000*100,))[::100] #每隔100个元素进行读取
x.strides #为了移动到相邻的下一个元素，需要跳转8个字节的距离
y.strides #为了移动到相邻的下一个元素，需要跳转800个字节的距离
x.shape, y.shape
%timeit x.sum() #这个快出下面10^3数量级
%timeit y.sum()
```

如果之后还要进行多次运算，为了防止执行速度下降，应当避免使用view进行计算，创建copy进行计算效率可能会更高。

```python
y_copy = np.copy(np.ones((100000*100,))[::100])
y_copy.strides
%timeit y_copy.sum()
```

### 广播

广播是在进行计算处理时，程序自动地对数组进行适当扩展的一种非常方便的功能。例如，在对下面的数组a中的所有元素进行加1计算时，只要使用下面这样非常简单的表达式即可实现。

```python
a += 1
```

此时，程序会自动对数组使用广播功能（无论a是包含多少个维度的数组）。甚至可以对二维数组与一维数组进行加法运算。

```python
a = np.array([1,2,3])
b = np.array([[1,1,1],[2,4,1]])
b + a
```

array([[2,3,4],

​            [3,6,4]])

## 广播

## 切片

## 关于坐标轴和维度

## ndarray的shape属性

## 元素数据类型的种类与指定方法

## 副图与视图的区别

# NumPy 与数组操作

## 数组形状变换函数

## 添加元素到数组末尾的函数

## 数组的真假值判断函数

## 指定条件获取元素索引的函数

## 最大值、最小值的筛选函数

## 返回数组中最大元素索引的函数

## 切换数组坐标轴顺序的函数

## 排序函数

## 数组拼接函数

## 数据可视化函数库

## 生成全零数组的函数

## 生成全1数组的函数

## 生成连续数列或等差数列的函数

## 生成线性等距数列的函数

## 生成单位矩阵的函数

## 生成未初始化数组的函数

## 随机数生成函数

## 数组的扁平化函数

## 文本文件的读写函数

## 直接存取数组数据的函数

## 将buffer快速转换为ndarray的函数

## 筛选非零元素的函数

## 比flatten更高速的数组扁平化函数

## 像铺瓷砖一样铺数组的函数

## 为数组增加维度的对象

## 数组元素的差分与求和函数

## 用于连接多维数组的对象

# NumPy 数学函数应用

## numpy中的数学函数和常量

## 计算元素平均值的函数

## 计算元素中位数的函数

## 元素的求和函数

## 计算标准差的函数

## 计算方差的函数

## 计算协方差的函数

## 计算相关系数的函数

## 根据数组元素生成网格的函数

## 内积计算函数

## 计算行列式的函数

## 计算矩阵的特征值和特征向量

## 计算矩阵的秩的函数

## 计算逆矩阵的函数

## 计算外积的函数

## 计算叉积的函数

## 计算卷积积分和移动平均的函数

# NumPy 机器学习编程

## 数组的归一化标准化算法

## 线性回归的numpy编程

## numpy神经网络编程（基础）

## numpy神经网络编程（理论）

## numpy神经网络编程（实践）

## numpy神经网络编程（深度学习）

## numpy神经网络编程（文字识别）

## numpy神经网络编程（强化学习）